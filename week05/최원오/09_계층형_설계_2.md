## 공부 내용

### 추상화 벽

- 팀 간 책임을 명확하게 나눈다. 이름 그대로 추상화 된 벽을 기준으로 추상화 된 함수를 사용하는 쪽과 추상화된 함수를 구현하는 구분되어진 느낌
- 추상화 벽 위에 있는 함수는 세부 데이터 구조를 몰라도 된다.

- 추상화 벽은 언제 사용해야하는가?

  - 변경 가능성이 높은 경우 (단, 쓸데없는 코드는 줄이자)
  - 코드를 읽고 쓰기 쉽게 만들기 위해 (세부 구현을 신경쓰지 않아도 되지만 함수가 어떤 역할을 하는지 명확하게 구분하기 위한 함수명과 파라미터명 등 추상화를 잘해야할 것 같다.)
  - 팀 간 조율을 줄이기위해
  - 주어진 문제에 집중하기위해? (크게 공감되진 않음 대규모 애플리케이션이라면 그럴지도?)

- p207
  장바구니를 알고 있는 모든 함수 - 데이터 구조가 변경됬기 때문에 장바구니를 알고있는 함수는 수정 되어야한다.

### 작은 인터페이스

- 새로운 코드를 추가할 위치에 관한 것
- 새로운 기능을 추가할 때 하위 계층에 기능을 추가하거나 고치기보다 상위 계층에 만든다.
  - 추상화 레벨을 깨지 않는다
  - 추상화 벽 계층에 기능을 추가하는 것은 큰 틀로 분리된 두 계층이 모두 알아야하기 때문에 코드 이해를 위한 시간이 더 소요된다.
  - 변동 가능성이 가장 높은 코드 일수록 상위 계층에 두는 것이랑 비슷한 느낌?

### 편리한 계층

- 설계와 새로운 기능의 필요성 사이 개발의 편리함과 코드 가독성을 고려하여 판단?
- 앞의 설계들을 보며 너무 이상적인 구조다라고 생각했는데 그런 내용이 딱 나왔다?

- 유지보수성은 상위로 연결된 것이 적은 함수가 바꾸기 쉽다.
- 테스트는 상위로 연결된 것이 많을수록 가치있다.
- 아래쪽에 함수가 적을수록 재사용하기 좋다.

## 알게된 점

- 외부 라이브러리는 추상화 벽을 두어 인터페이스를 통해 사용하는 것이 나중에 유지보수에 유리하겠다
- 프로그래밍 전반적으로 고수준의 정책이 저수준의 구체적인 구현을 모르고 인터페이스로 소통하는 건 모든 개념에 다 들어가는듯?

## 궁금한 점
